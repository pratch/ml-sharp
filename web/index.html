<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Three.js SplatMesh Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>

    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      width: 100vw;
      min-height: 100vh;
      min-width: 100vw;
      background: #000;
      margin: 0px;
    }

    #controls {
      margin-top: 12px;
      margin-bottom: 12px;
      background: rgba(30, 30, 30, 0.95);
      border-radius: 12px;
      padding: 18px 32px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.3);
      display: none;
      flex-direction: row;
      gap: 32px;
      align-items: center;
      color: #fff;
      font-family: 'Segoe UI', Arial, sans-serif;
      font-size: 1.1em;
    }
    #controls label {
      margin-right: 8px;
      font-weight: 500;
    }
    #controls input[type="range"] {
      width: 160px;
      accent-color: #4f8cff;
      margin: 0 12px 0 0;
      vertical-align: middle;
      background: transparent;
    }
    #controls span {
      display: inline-block;
      min-width: 3.5em;
      text-align: right;
      font-variant-numeric: tabular-nums;
      color: #b2d1ff;
    }

    #container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: 100%;
    }

    #save-sbs {
      display: none;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
      "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.10/spark.module.js",
      "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/controls/OrbitControls.min.js"
    }
  }
</script>
<script src="https://cdn.jsdelivr.net/npm/stats-js@1.0.1/build/stats.min.js"></script>
</head>

<body>
  <div id="container"></div>
  <button id="save-sbs" style="position:fixed;top:20px;right:20px;z-index:10;">Save Side-by-Side Image</button>
  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import {SplatMesh} from "@sparkjsdev/spark";
    import * as dat from "https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.module.js";
    import { PLYLoader } from "https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/PLYLoader.min.js";
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.178.0/examples/jsm/loaders/GLTFLoader.min.js';
  
    const stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    document.body.appendChild(stats.dom);

    // Get scene from URL (?scene=...) or use default
    function getQueryParam(name) {
      const params = new URLSearchParams(window.location.search);
      return params.get(name);
    }
    let file = getQueryParam('scene') || "20251023_155037";
    let plyURL = `../output2/${file}.ply`;
    let jsonURL = `../output2/${file}.json`;

    let ui = getQueryParam('ui') || "true";
    let hybrid = getQueryParam('hybrid') || "false";

    // let width = 4000;
    // let height = 3000;
    let meta;

    await fetch(jsonURL)
      .then(response => response.json())
      .then(meta_in => {
        meta = meta_in;
      });

    let width = meta.width, height = meta.height;
    let ratio = width / height;
    // let innerWidth = window.innerWidth;
    // let innerHeight = window.innerHeight;
    const container = document.getElementById('container');
    const innerWidth = container.clientWidth;
    const innerHeight = container.clientHeight;

    let usableWidth = innerWidth; 
    let usableHeight = innerHeight; 

    if (usableWidth < width) {
      width = usableWidth;
      height = width / ratio;
    }
    if (usableHeight < height) {
      height = usableHeight;
      width = height * ratio;
    }

    let linspace = [];
    let numPoints = 100;
    for (let i = 0; i < numPoints; i++) {
      let t = i / (numPoints - 1);
      // let value = (1-t) / meta.percentile_1_depth + t / meta.percentile_99_depth;
      let value = (1-t) / meta.min_depth + t / meta.max_depth;
      linspace.push(value);
    }

    // const width = window.innerWidth;
    // const height = window.innerHeight;

    const scene = new THREE.Scene();
    // const camera = new THREE.PerspectiveCamera(54.88, ratio, 0.1, 1000);
    const camera = new THREE.PerspectiveCamera(meta.vertical_fov_degrees, ratio, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    // renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setPixelRatio(2);
    // alert( window.devicePixelRatio );
    // renderer.setPixelRatio(2);
    renderer.setSize(width, height);
    document.getElementById('container').appendChild(renderer.domElement)

    // let median_depth = meta.median_depth;
    let median_depth = 1 / linspace[50];
    let center_depth = median_depth;

    let center = new THREE.Vector3(0, 0, -center_depth);
    const controls = new OrbitControls(camera, renderer.domElement);


    console.log("median depth:", median_depth);
    const angle = 20;
    const distance = meta.percentile_99_depth - meta.percentile_1_depth
    const kz = meta.percentile_99_depth - distance * Math.cos(angle * Math.PI / 180);
    const ky = distance * Math.sin(angle * Math.PI / 180);

    const cc = meta.focal_length_px * ky / kz;
    console.log("perc 1 depth:", meta.percentile_1_depth);
    console.log("perc 99 depth:", meta.percentile_99_depth);
    console.log(cc);

    controls.rotateSpeed = 800 / cc;
    controls.target.copy(center);
    controls.enablePan = true;
    controls.update();


    // --- Side-by-side save functionality ---
    document.getElementById('save-sbs').onclick = async function () {
      const sbsWidth = width * 2;
      const sbsHeight = height;
      const sbsCanvas = document.createElement('canvas');
      sbsCanvas.width = sbsWidth;
      sbsCanvas.height = sbsHeight;
      const sbsCtx = sbsCanvas.getContext('2d');

      // Save original camera position
      const origPos = camera.position.clone();
      const origQuat = camera.quaternion.clone();

      // Stereo offset
      const eyeSep = 0.03;

      // LEFT EYE
      camera.position.x = origPos.x - eyeSep;
      camera.updateMatrixWorld();
      camera.lookAt(0, 0, -5);
      renderer.render(scene, camera);
      sbsCtx.drawImage(renderer.domElement, 0, 0, width, height, 0, 0, width, height);

      // RIGHT EYE
      camera.position.x = origPos.x + eyeSep;
      camera.updateMatrixWorld();
      camera.lookAt(0, 0, -5);
      renderer.render(scene, camera);
      sbsCtx.drawImage(renderer.domElement, 0, 0, width, height, width, 0, width, height);

      // Restore camera
      camera.position.copy(origPos);
      camera.quaternion.copy(origQuat);
      camera.updateMatrixWorld();
      renderer.render(scene, camera);

      // Download
      const link = document.createElement('a');
      link.download = 'side_by_side.png';
      link.href = sbsCanvas.toDataURL('image/png');
      link.click();
    }



    let splatURL = plyURL, meshURL = plyURL;
    if (hybrid === "true") {
      splatURL = splatURL.replace(".ply", "_pruned.ply");
      // meshURL = meshURL.replace(".ply", "_mesh.ply");
      meshURL = meshURL.replace(".ply", "_mesh.glb");
    }

    const splat = new SplatMesh({url: splatURL});
    
    // const splat = new SplatMesh({url: plyURL});
    splat.quaternion.set(1, 0, 0, 0);
    splat.position.set(0, 0, 0);
    scene.add(splat);

    let meshObj = null;

    let guiParams = {
      cameraMotion: "None",
      amplitude: 2,
      speed: 1,
      center: 50,
      showMesh: true,
      showSplat: true
    };
    splat.visible = guiParams.showSplat;

    if (hybrid == "true") {
      /*
      const loader = new PLYLoader();
      loader.load(meshURL, function (geometry) {
        geometry.computeVertexNormals();
        // If your PLY has vertex colors, use vertexColors: true
        const material = new THREE.MeshBasicMaterial({ vertexColors: true });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.quaternion.set(1, 0, 0, 0);
        mesh.position.set(0, 0, 0);
        mesh.visible = guiParams.showMesh;
        scene.add(mesh);
        meshObj = mesh;
        // alert("added");
      });
      */
      const loader = new GLTFLoader();
      loader.load(meshURL, function (gltf) {
        const model = gltf.scene;
        model.quaternion.set(1, 0, 0, 0);
        model.position.set(0, 0, 0);
        model.visible = guiParams.showMesh;
        scene.add(model);
        meshObj = model;


        model.traverse((child) => {
          if (child.isMesh) {
              // Grab the original PBR material created by the loader
              const originalMaterial = child.material;

              child.material = new THREE.MeshBasicMaterial({
                  map: originalMaterial.map, // This is your UV texture
                  side: THREE.DoubleSide,    // Ensures both sides of faces are visible
              });

              if (child.material.map) {
                  child.material.map.colorSpace = THREE.SRGBColorSpace;
              }
          }
        });


      });
      scene.add(new THREE.AmbientLight(0xffffff, 1.0)); // Full ambient, no shadows

    }

    const gui = new dat.GUI();
    gui.add(guiParams, 'cameraMotion', ["None", "SpiralXYZ", "SpiralXY"]);
    gui.add(guiParams, 'amplitude', 0, 10, 0.1);
    gui.add(guiParams, 'speed', 0.1, 5, 0.1);
    gui.add(guiParams, 'center', 0, 99, 1).onChange((value) => {
      center_depth = 1/linspace[Math.floor(value)];
      let new_center = new THREE.Vector3(0, 0, -center_depth);
      controls.target.copy(new_center);
      controls.update();
    });
    gui.add(guiParams, 'showMesh').onChange((value) => {
      if (meshObj) meshObj.visible = value;
    });
    gui.add(guiParams, 'showSplat').onChange((value) => {
      if (splat) splat.visible = value;
    });
    if (ui === "false") {
      gui.hide();
    }

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        if (guiParams.cameraMotion != "None") {
          guiParams.cameraMotion = "None";
          gui.updateDisplay();
        } else {
          camera.position.set(0, 0, 0);
          center_depth = median_depth;
          camera.lookAt(0, 0, -center_depth);
        }
      }
    });

    renderer.setAnimationLoop(function animate(time) {
      stats.begin();
      let amplitude = guiParams.amplitude * 0.005 * distance;
      let speed = guiParams.speed * 0.001;
      let cameraMotion = guiParams.cameraMotion;
      if (cameraMotion === "SpiralXYZ") {
        camera.position.x = amplitude * Math.sin(time * speed);
        camera.position.y = 0.5 * amplitude * Math.sin(2 * time * speed);
        camera.position.z = 2 * amplitude * (Math.sin(0.5 * time * speed) - 1);
      } else if (cameraMotion === "SpiralXY") {
        camera.position.x = amplitude * Math.sin(time * speed);
        camera.position.y = 0.5 * amplitude * Math.sin(2 * time * speed);
      }
      controls.update();
      renderer.render(scene, camera);
      // splat.rotation.y += 0.01;
      stats.end();
    });
  </script>

</body>

</html>
